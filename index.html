<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>r/IndianRailways — Subscribers</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<style>
:root{
  --bg:#0f1113;
  --panel:#111214;
  --muted:#bbb;
  --accent:#4CAF50;
  --card-radius:12px;
  --pad:16px;
}
body{
  margin:0;
  font-family:Inter,Arial,Helvetica,sans-serif;
  background:linear-gradient(180deg,#0b0b0d 0%,#121214 100%);
  color:#fff;
  padding:20px;
  -webkit-font-smoothing:antialiased;
}
.container{ max-width:980px; margin:0 auto; }
header { text-align:center; margin-bottom:8px; }
h1 { margin:6px 0; font-size:1.6rem; font-weight:600; }
#count { font-size:3.8rem; font-weight:800; color:var(--accent); letter-spacing:0.02em; }
.card {
  background: rgba(255,255,255,0.02);
  border-radius:var(--card-radius);
  padding:var(--pad);
  margin:12px 0;
  box-shadow:0 6px 18px rgba(0,0,0,0.45);
}
.stats { display:flex; gap:12px; flex-wrap:wrap; justify-content:center; }
.stat {
  min-width:180px;
  background:rgba(255,255,255,0.02);
  padding:12px;
  border-radius:10px;
  text-align:center;
}
.stat b { display:block; font-size:0.95rem; margin-bottom:6px; color:#fff; }
.stat .val { font-size:1.25rem; font-weight:700; color:var(--accent); }
.stat .prev { color:var(--muted); font-size:0.85rem; margin-top:6px; display:block; }
#lastUpdated { color:var(--muted); text-align:center; margin-top:8px; font-size:0.9rem; }

/* tabs */
.tabs { display:flex; gap:8px; justify-content:center; margin-top:18px; flex-wrap:wrap; }
.tab-btn { background:#222; color:#ddd; border-radius:8px; padding:8px 12px; border:none; cursor:pointer; }
.tab-btn.active { background:var(--accent); color:#021805; font-weight:700; }

/* FIX: Canvas height controlled by parent wrapper */
.chart-container { position: relative; height: 300px; margin-top: 12px; }
canvas { max-width:100%; display:block; }

@media (max-width:640px){
  #count { font-size:2.4rem; }
  .stat { min-width:140px; }
  h1 { font-size:1.2rem; }
}

button { padding:10px 20px; font-size:1rem; cursor:pointer; margin-top:10px; display:block; margin-left:auto; margin-right:auto; }
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>r/IndianRailways Subscribers</h1>
    <div id="count">—</div>
  </header>

  <button onclick="updateSubs()">Update Now</button>

  <div class="card">
    <div class="stats">
      <div class="stat">
        <b>Growth Today</b>
        <div class="val" id="dailyGrowth">0</div>
        <div class="prev" id="dailyPrev">from —</div>
      </div>
      <div class="stat">
        <b>Growth This Week</b>
        <div class="val" id="weeklyGrowth">0</div>
        <div class="prev" id="weeklyPrev">from —</div>
      </div>
      <div class="stat">
        <b>Growth This Month</b>
        <div class="val" id="monthlyGrowth">0</div>
        <div class="prev" id="monthlyPrev">from —</div>
      </div>
      <div class="stat">
        <b>Growth This Year</b>
        <div class="val" id="yearlyGrowth">0</div>
        <div class="prev" id="yearlyPrev">from —</div>
      </div>
    </div>
    <div id="lastUpdated">Last updated: — (IST)</div>
  </div>

  <div class="card">
    <div style="text-align:center"><small class="muted">Graph range</small></div>
    <div class="tabs" role="tablist" aria-label="Ranges">
      <button class="tab-btn" data-range="24h">24 Hours</button>
      <button class="tab-btn" data-range="7d">7 Days</button>
      <button class="tab-btn" data-range="30d">30 Days</button>
      <button class="tab-btn active" data-range="12m">12 Months</button>
    </div>
    <div class="chart-container">
      <canvas id="growthChart"></canvas>
    </div>
  </div>

  <div style="text-align:center; color:var(--muted); margin-top:10px;">
    Data stored in <code>data.json</code> (updated hourly by GitHub Actions). Live fallback always works.
  </div>
</div>

<script>
/*
  Improvements:
  - Accurate countAtTime(t) using interpolation.
  - Growth metrics use the value at start-of-period (IST).
  - Chart baseline uses the same value so ranges show small upticks correctly.
*/

const DATA_URL = 'data.json';
const SUBREDDIT = 'indianrailways';

// seed values used only as fallbacks
const LATEST_COUNT = 349693;
const GROWTH_TODAY = 8;
const GROWTH_WEEK = 1318;
const GROWTH_MONTH = 5608;
const GROWTH_YEAR = 105008;

let logs = [];              // array of {time: ms, count: number}
let chart = null;
let currentRange = '12m';

const DAY_MS = 24*60*60*1000;
const HOUR_MS = 60*60*1000;

function asNumber(n){ return +n; }
function toISTDate(ms){
  return new Date(ms).toLocaleDateString('en-IN', { timeZone:'Asia/Kolkata', day:'numeric', month:'short', year:'numeric' });
}
function formatNumberIndian(n){
  return new Intl.NumberFormat('en-IN').format(n);
}
function formatGrowth(val){
  return (val>=0?'+':'') + formatNumberIndian(val);
}

// fetch data.json (preferred), else localStorage, else seeded logs
async function fetchDataJson(){
  try {
    const res = await fetch(DATA_URL + '?t=' + Date.now(), { cache: 'no-store' });
    if(!res.ok) throw new Error('data.json not available');
    const json = await res.json();
    const parsed = (json.logs || []).map(l => ({ time: asNumber(l.time), count: asNumber(l.count) }));
    parsed.sort((a,b)=>a.time-b.time);
    const hasRealCounts = parsed.some(p => p.count && p.count > 0);
    if(hasRealCounts){
      logs = parsed;
      localStorage.setItem('sharedLogs', JSON.stringify(logs));
      return true;
    } else {
      throw new Error('data.json contains no real counts');
    }
  } catch(e){
    console.warn('fetchDataJson failed:', e);
    const cached = localStorage.getItem('sharedLogs');
    if(cached){
      try{
        const parsed = JSON.parse(cached);
        if(Array.isArray(parsed) && parsed.length){
          logs = parsed.map(l => ({time: asNumber(l.time), count: asNumber(l.count)}));
          logs.sort((a,b)=>a.time-b.time);
          return true;
        }
      }catch(err){
        console.warn('localStorage parse failed', err);
      }
    }
    logs = generateSeedLogs();
    localStorage.setItem('sharedLogs', JSON.stringify(logs));
    return false;
  }
}

// live fetch (best-effort)
async function fetchLiveCount(){
  try {
    const res = await fetch(`https://www.reddit.com/r/${SUBREDDIT}/about.json?raw_json=1`, { cache:'no-store' });
    if(!res.ok) throw new Error('reddit fetch failed ' + res.status);
    const json = await res.json();
    const count = Number(json?.data?.subscribers || 0);
    if(count && count > 0) return count;
    throw new Error('reddit returned invalid count');
  } catch(e){
    console.warn('Live reddit fetch failed:', e);
    return null;
  }
}

// produce seeded historical logs if nothing else exists
function generateSeedLogs(){
  const now = Date.now();
  const startCount = LATEST_COUNT - GROWTH_YEAR;
  const totalDays = 365;

  const daily = [];
  for(let d=0; d<=totalDays; d++){
    const frac = d / totalDays;
    const time = now - (totalDays - d) * DAY_MS;
    const base = Math.round(startCount + GROWTH_YEAR * Math.pow(frac, 1.05));
    const jitter = Math.round((Math.random()-0.5) * 150);
    daily.push({ time: time, count: Math.max(0, base + jitter) });
  }

  const hourly = [];
  const hours = 30 * 24;
  for(let h=0; h<=hours; h++){
    const time = now - (hours - h) * HOUR_MS;
    const dayIndex = totalDays - 30 + (h / 24);
    const frac = Math.max(0, Math.min(1, dayIndex / totalDays));
    const base = Math.round(startCount + GROWTH_YEAR * Math.pow(frac, 1.05));
    const jitter = Math.round((Math.random()-0.5) * 80);
    hourly.push({ time: time, count: Math.max(0, base + jitter) });
  }

  const map = new Map();
  daily.forEach(p => map.set(p.time, p.count));
  hourly.forEach(p => map.set(p.time, p.count));
  map.set(now, LATEST_COUNT);

  const combined = Array.from(map.entries()).map(([time,count])=>({time, count}));
  combined.sort((a,b)=>a.time-b.time);
  return combined;
}

function getLatest(){ return logs.length ? logs[logs.length-1] : { time: Date.now(), count: LATEST_COUNT }; }

// --- NEW: accurate interpolation function ---
// returns the subscriber count at arbitrary timestamp t (ms).
// If t falls between two logged samples we linearly interpolate.
function countAtTime(t){
  if(!logs.length) return null;
  // before earliest log -> return earliest
  if(t <= logs[0].time) return logs[0].count;
  const lastIdx = logs.length - 1;
  if(t >= logs[lastIdx].time) return logs[lastIdx].count;

  // binary search for index i where logs[i].time <= t < logs[i+1].time
  let lo = 0, hi = lastIdx;
  while(lo <= hi){
    const mid = Math.floor((lo + hi) / 2);
    if(logs[mid].time === t) return logs[mid].count;
    if(logs[mid].time < t) lo = mid + 1;
    else hi = mid - 1;
  }
  // now hi is the index with logs[hi].time < t and lo = hi+1
  const i = Math.max(0, hi);
  const j = i + 1;
  if(j >= logs.length) return logs[i].count;
  const t0 = logs[i].time, t1 = logs[j].time;
  const c0 = logs[i].count, c1 = logs[j].count;
  if(t1 === t0) return c0;
  const ratio = (t - t0) / (t1 - t0);
  return Math.round(c0 + (c1 - c0) * ratio);
}

// Build IST midnight timestamp for given Y/M/D
function istMidnightMs(year, monthIndex, day){
  const mm = String(monthIndex+1).padStart(2,'0');
  const dd = String(day).padStart(2,'0');
  const iso = `${year}-${mm}-${dd}T00:00:00+05:30`;
  return new Date(iso).getTime();
}

async function updateSubs(){
  await fetchDataJson();

  // live best-effort
  const liveCount = await fetchLiveCount();

  if(liveCount && (!logs.length || logs[logs.length-1].count !== liveCount)){
    const nowMs = Date.now();
    logs.push({ time: nowMs, count: liveCount });
    if(logs.length > 10000) logs = logs.slice(-10000);
    localStorage.setItem('sharedLogs', JSON.stringify(logs));
  }

  const latest = (liveCount || (logs.length ? logs[logs.length-1].count : LATEST_COUNT));
  document.getElementById('count').textContent = formatNumberIndian(latest);

  // IST-aware starts (midnight IST)
  const now = new Date();
  const istNow = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Kolkata' }));
  const year = istNow.getFullYear(), month = istNow.getMonth(), day = istNow.getDate();

  const bDayMs = istMidnightMs(year, month, day);
  const bMonthMs = istMidnightMs(year, month, 1);
  const bYearMs = istMidnightMs(year, 0, 1);

  const dayOfWeek = istNow.getDay(); // Sunday=0
  const daysToMonday = (dayOfWeek === 0) ? 6 : (dayOfWeek - 1);
  const bWeekMs = bDayMs - daysToMonday * DAY_MS;

  // use interpolation to get baseline values at exact start times (if logs exist)
  let baseDay = countAtTime(bDayMs);
  let baseWeek = countAtTime(bWeekMs);
  let baseMonth = countAtTime(bMonthMs);
  let baseYear = countAtTime(bYearMs);

  // fall back to seed deltas only if interpolation returned null (no logs)
  if(baseDay === null) baseDay = latest - GROWTH_TODAY;
  if(baseWeek === null) baseWeek = latest - GROWTH_WEEK;
  if(baseMonth === null) baseMonth = latest - GROWTH_MONTH;
  if(baseYear === null) baseYear = latest - GROWTH_YEAR;

  document.getElementById('dailyGrowth').textContent = formatGrowth(latest - baseDay);
  document.getElementById('dailyPrev').textContent = 'from ' + toISTDate(bDayMs);

  document.getElementById('weeklyGrowth').textContent = formatGrowth(latest - baseWeek);
  document.getElementById('weeklyPrev').textContent = 'from ' + toISTDate(bWeekMs);

  document.getElementById('monthlyGrowth').textContent = formatGrowth(latest - baseMonth);
  document.getElementById('monthlyPrev').textContent = 'from ' + toISTDate(bMonthMs);

  document.getElementById('yearlyGrowth').textContent = formatGrowth(latest - baseYear);
  document.getElementById('yearlyPrev').textContent = 'from ' + toISTDate(bYearMs);

  document.getElementById('lastUpdated').textContent =
    'Last updated: ' + new Date().toLocaleString('en-IN', { timeZone:'Asia/Kolkata', dateStyle:'medium', timeStyle:'short' });

  renderChart();
}

// Render Chart.js using interpolated baseline for the range start
function renderChart(){
  const canvas = document.getElementById('growthChart');
  const ctx = canvas.getContext('2d');
  if(!logs.length) return;

  const now = Date.now();
  const rangeMs = { '24h': 24*HOUR_MS, '7d': 7*DAY_MS, '30d': 30*DAY_MS, '12m': 365*DAY_MS }[currentRange];
  const rangeStart = now - rangeMs;

  // Filter logs that fall inside the range, but we'll anchor a point at rangeStart
  let filtered = logs.filter(l => l.time >= rangeStart);

  // If there is a log before rangeStart, include it so we can interpolate; else we'll create a synthetic baseline
  const before = logs.slice().reverse().find(l => l.time < rangeStart);
  const baselineVal = (countAtTime(rangeStart) !== null) ? countAtTime(rangeStart) : (getLatest().count - (currentRange === '24h' ? GROWTH_TODAY : currentRange === '7d' ? GROWTH_WEEK : currentRange === '30d' ? GROWTH_MONTH : GROWTH_YEAR));

  // Insert the baseline point at rangeStart (if filtered doesn't already begin at or before it)
  if(filtered.length === 0 || filtered[0].time > rangeStart){
    filtered.unshift({ time: rangeStart, count: baselineVal });
  } else {
    // if filtered[0].time === rangeStart leave it; if first is after rangeStart, unshift baseline
    if(filtered[0].time > rangeStart){
      filtered.unshift({ time: rangeStart, count: baselineVal });
    }
  }

  // Ensure we show the latest point (if live recently appended)
  const last = getLatest();
  if(!filtered.length || filtered[filtered.length-1].time < last.time){
    filtered.push(last);
  }

  const dataPoints = filtered.map(p => ({ x: p.time, y: p.count }));

  if(chart){
    chart.destroy();
    chart = null;
  }

  const yVals = dataPoints.map(p=>p.y);
  const yMin = Math.min(...yVals);
  const yMax = Math.max(...yVals);
  const pad = Math.max(1, Math.round((yMax - yMin) * 0.06)); // add 6% padding to top/bottom

  const unit = currentRange === '24h' ? 'hour' : (currentRange === '7d' ? 'day' : (currentRange === '30d' ? 'day' : 'month'));

  chart = new Chart(ctx, {
    type: 'line',
    data: {
      datasets: [{
        label: 'Subscribers',
        data: dataPoints,
        borderColor: '#4CAF50',
        borderWidth: 2,
        pointRadius: 2,
        pointBackgroundColor: '#4CAF50',
        tension: 0.15,
        fill: false
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      parsing: false,
      scales: {
        x: {
          type: 'time',
          time: { unit },
          ticks: { color: 'rgba(255,255,255,0.7)' },
          grid: { color: 'rgba(255,255,255,0.06)' }
        },
        y: {
          suggestedMin: Math.max(0, yMin - pad),
          suggestedMax: yMax + pad,
          ticks: {
            color: 'rgba(255,255,255,0.7)',
            callback: val => formatNumberIndian(val)
          },
          grid: { color: 'rgba(255,255,255,0.06)' }
        }
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: ctx => 'Subscribers: ' + formatNumberIndian(ctx.parsed.y)
          }
        }
      }
    }
  });
}

// tab logic
document.querySelectorAll('.tab-btn').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('.tab-btn').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    currentRange = btn.dataset.range;
    renderChart();
  });
});

// initial load
updateSubs();

// refresh hourly in browser
setInterval(() => {
  updateSubs().catch(e => console.warn('auto update failed', e));
}, 60*60*1000);
</script>
</body>
</html>
