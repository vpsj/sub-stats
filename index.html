<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>r/IndianRailways — Subscribers</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<style>
:root{
  --bg:#0f1113;
  --panel:#111214;
  --muted:#bbb;
  --accent:#4CAF50;
  --card-radius:12px;
  --pad:16px;
}
body{
  margin:0;
  font-family:Inter,Arial,Helvetica,sans-serif;
  background:linear-gradient(180deg,#0b0b0d 0%,#121214 100%);
  color:#fff;
  padding:20px;
  -webkit-font-smoothing:antialiased;
}
.container{ max-width:980px; margin:0 auto; }
header { text-align:center; margin-bottom:8px; }
h1 { margin:6px 0; font-size:1.6rem; font-weight:600; }
#count { font-size:3.8rem; font-weight:800; color:var(--accent); letter-spacing:0.02em; }
.card {
  background: rgba(255,255,255,0.02);
  border-radius:var(--card-radius);
  padding:var(--pad);
  margin:12px 0;
  box-shadow:0 6px 18px rgba(0,0,0,0.45);
}
.stats { display:flex; gap:12px; flex-wrap:wrap; justify-content:center; }
.stat {
  min-width:180px;
  background:rgba(255,255,255,0.02);
  padding:12px;
  border-radius:10px;
  text-align:center;
}
.stat b { display:block; font-size:0.95rem; margin-bottom:6px; color:#fff; }
.stat .val { font-size:1.25rem; font-weight:700; color:var(--accent); }
.stat .prev { color:var(--muted); font-size:0.85rem; margin-top:6px; display:block; }
#lastUpdated { color:var(--muted); text-align:center; margin-top:8px; font-size:0.9rem; }

/* tabs */
.tabs { display:flex; gap:8px; justify-content:center; margin-top:18px; flex-wrap:wrap; }
.tab-btn { background:#222; color:#ddd; border-radius:8px; padding:8px 12px; border:none; cursor:pointer; }
.tab-btn.active { background:var(--accent); color:#021805; font-weight:700; }

/* FIX: Canvas height controlled by parent wrapper */
.chart-container { position: relative; height: 300px; margin-top: 12px; }
canvas { max-width:100%; display:block; }

@media (max-width:640px){
  #count { font-size:2.4rem; }
  .stat { min-width:140px; }
  h1 { font-size:1.2rem; }
}

button { padding:10px 20px; font-size:1rem; cursor:pointer; margin-top:10px; display:block; margin-left:auto; margin-right:auto; }
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>r/IndianRailways Subscribers</h1>
    <div id="count">—</div>
  </header>

  <button onclick="updateSubs()">Update Now</button>

  <div class="card">
    <div class="stats">
      <div class="stat">
        <b>Growth Today</b>
        <div class="val" id="dailyGrowth">0</div>
        <div class="prev" id="dailyPrev">from —</div>
      </div>
      <div class="stat">
        <b>Growth This Week</b>
        <div class="val" id="weeklyGrowth">0</div>
        <div class="prev" id="weeklyPrev">from —</div>
      </div>
      <div class="stat">
        <b>Growth This Month</b>
        <div class="val" id="monthlyGrowth">0</div>
        <div class="prev" id="monthlyPrev">from —</div>
      </div>
      <div class="stat">
        <b>Growth This Year</b>
        <div class="val" id="yearlyGrowth">0</div>
        <div class="prev" id="yearlyPrev">from —</div>
      </div>
    </div>
    <div id="lastUpdated">Last updated: — (IST)</div>
  </div>

  <div class="card">
    <div style="text-align:center"><small class="muted">Graph range</small></div>
    <div class="tabs" role="tablist" aria-label="Ranges">
      <button class="tab-btn" data-range="24h">24 Hours</button>
      <button class="tab-btn" data-range="7d">7 Days</button>
      <button class="tab-btn" data-range="30d">30 Days</button>
      <button class="tab-btn active" data-range="12m">12 Months</button>
    </div>
    <div class="chart-container">
      <canvas id="growthChart"></canvas>
    </div>
  </div>

  <div style="text-align:center; color:var(--muted); margin-top:10px;">
    Data stored in <code>data.json</code> (updated hourly by GitHub Actions). Live fallback always works.
  </div>
</div>

<script>
/*
  REVISED LOGIC:
  - Establishes a firm, mathematically correct anchor point for 12 months ago.
  - All other historical data, including the 'start of year' value, is interpolated from this corrected timeline.
  - This fixes the 12-month graph and makes all growth figures consistent.
*/

const DATA_URL = 'data.json';
const SUBREDDIT = 'indianrailways';

// Seed values based on user-provided insights
const LATEST_COUNT = 349746;
const GROWTH_TODAY = 188;       // Growth since midnight
const GROWTH_WEEK = 1300;       // Growth in the last 7 days
const GROWTH_MONTH = 5600;      // Growth in the last 30 days
const GROWTH_YEAR = 105000;     // Growth in the last 12 months (365 days)

let logs = [];
let chart = null;
let currentRange = '12m';

const DAY_MS = 24*60*60*1000;
const HOUR_MS = 60*60*1000;

// formatting helpers
function asNumber(n){ return +n; }
function formatNumberIndian(n){ return new Intl.NumberFormat('en-IN').format(n); }
function formatGrowth(val){ return (val>=0?'+':'') + formatNumberIndian(val); }
function toISTDate(ms){ return new Date(ms).toLocaleDateString('en-IN', { timeZone:'Asia/Kolkata', day:'numeric', month:'short' }); }

// --- Fetch data.json or fallback ---
async function fetchDataJson(){
  try {
    const res = await fetch(DATA_URL + '?t=' + Date.now(), { cache: 'no-store' });
    if(!res.ok) throw new Error('data.json not available');
    const json = await res.json();
    const parsed = (json.logs || []).map(l => ({ time: asNumber(l.time), count: asNumber(l.count) }));
    parsed.sort((a,b)=>a.time-b.time);
    if(parsed.some(p => Number.isFinite(p.count) && p.count > 0)){
      logs = parsed;
      localStorage.setItem('sharedLogs', JSON.stringify(logs));
      return true;
    } else {
      throw new Error('data.json empty');
    }
  } catch(e){
    console.warn('fetchDataJson failed:', e.message || e);
    const cached = localStorage.getItem('sharedLogs');
    if(cached){
      try {
        const parsed = JSON.parse(cached);
        if(Array.isArray(parsed) && parsed.length){
          logs = parsed.map(l => ({ time: asNumber(l.time), count: asNumber(l.count) }));
          return true;
        }
      } catch(err){ console.warn('localStorage parse failed', err); }
    }
    // fallback: generate logs from seed values
    logs = generateAnchoredSeedLogs();
    localStorage.setItem('sharedLogs', JSON.stringify(logs));
    return false;
  }
}

// Live fetch from Reddit
async function fetchLiveCount(){
  try {
    const res = await fetch(`https://www.reddit.com/r/${SUBREDDIT}/about.json?raw_json=1`, { cache:'no-store' });
    if(!res.ok) throw new Error('reddit fetch failed');
    const json = await res.json();
    const count = Number(json?.data?.subscribers || 0);
    return (count > 0) ? count : null;
  } catch(e){
    console.warn('Live reddit fetch failed:', e.message || e);
    return null;
  }
}

// --- **REVISED** function to generate correct historical data ---
function generateAnchoredSeedLogs(){
  const now = Date.now();
  const istNow = new Date(new Date().toLocaleString('en-US', { timeZone: 'Asia/Kolkata' }));

  // Define period start timestamps relative to now
  const startOfDay = istMidnightMs(istNow.getFullYear(), istNow.getMonth(), istNow.getDate());
  const dayOfWeek = istNow.getDay();
  const daysToMonday = (dayOfWeek === 0) ? 6 : (dayOfWeek - 1);
  const startOfWeek = startOfDay - daysToMonday * DAY_MS;
  const startOfMonth = istMidnightMs(istNow.getFullYear(), istNow.getMonth(), 1);
  const startOf12MonthsAgo = now - 365 * DAY_MS;

  // Calculate anchor counts by subtracting growth from the latest count
  const anchorNow = LATEST_COUNT;
  const anchorDay = anchorNow - GROWTH_TODAY;
  const anchorWeek = anchorNow - GROWTH_WEEK;
  const anchorMonth = anchorNow - GROWTH_MONTH;
  const anchor12Months = anchorNow - GROWTH_YEAR; // This is the key fix

  // Define the main anchor points for interpolation.
  // The earliest point is now 12 months ago, making the graph accurate.
  const anchors = [
    { t: startOf12MonthsAgo, v: anchor12Months },
    { t: startOfMonth, v: Math.max(anchor12Months, anchorMonth) },
    { t: startOfWeek, v: Math.max(anchorMonth, anchorWeek) },
    { t: startOfDay, v: Math.max(anchorWeek, anchorDay) },
    { t: now, v: anchorNow }
  ].filter(a => a.t <= now); // Ensure no future anchors

  // helper to interpolate points between two anchors
  function pointsBetween(a, b, stepMs){
    const pts = [];
    if(b.t <= a.t) return pts;
    for(let t = a.t; t < b.t; t += stepMs){
      const ratio = (t - a.t) / (b.t - a.t);
      const v = Math.round(a.v + (b.v - a.v) * ratio);
      pts.push({ time: Math.round(t), count: v });
    }
    return pts;
  }

  let result = [];
  // Interpolate between the defined anchors with varying granularity
  for(let i=0; i < anchors.length - 1; i++){
    const a = anchors[i];
    const b = anchors[i+1];
    const duration = b.t - a.t;
    let step = DAY_MS * 7; // Default weekly points for long periods
    if (duration <= 2 * DAY_MS) step = HOUR_MS; // Hourly for last day
    else if (duration <= 10 * DAY_MS) step = DAY_MS / 4; // 6-hourly for last week
    else if (duration <= 45 * DAY_MS) step = DAY_MS; // Daily for last month
    result.push(...pointsBetween(a, b, step));
  }
  // Add the anchor points themselves to ensure they are included
  anchors.forEach(a => result.push({ time: a.t, count: Math.round(a.v) }));

  // De-duplicate and sort
  const map = new Map();
  result.forEach(p => map.set(p.time, Math.round(p.count)));
  const combined = Array.from(map.entries()).map(([time, count])=>({ time, count }));
  combined.sort((x,y)=>x.time-y.time);
  return combined;
}

function istMidnightMs(y, m, d){
  return new Date(`${y}-${String(m+1).padStart(2,'0')}-${String(d).padStart(2,'0')}T00:00:00+05:30`).getTime();
}

function getLatest(){ return logs.length ? logs[logs.length-1] : { time: Date.now(), count: LATEST_COUNT }; }

// Interpolates subscriber count at a given timestamp
function countAtTime(t){
  if(!logs.length) return null;
  if(t <= logs[0].time) return logs[0].count;
  const last = logs[logs.length - 1];
  if(t >= last.time) return last.count;

  let lo = 0, hi = logs.length - 1;
  while(lo <= hi){
    const mid = Math.floor((lo + hi)/2);
    if(logs[mid].time === t) return logs[mid].count;
    if(logs[mid].time < t) lo = mid + 1;
    else hi = mid - 1;
  }
  const i = Math.max(0, hi);
  const a = logs[i], b = logs[i+1];
  const ratio = (t - a.time) / (b.time - a.time);
  return Math.round(a.count + (b.count - a.count) * ratio);
}

// Main function to update all UI elements
async function updateSubs(){
  await fetchDataJson();
  const live = await fetchLiveCount();
  if(live && (!logs.length || getLatest().count !== live)){
    logs.push({ time: Date.now(), count: live });
    localStorage.setItem('sharedLogs', JSON.stringify(logs));
  }

  const latest = getLatest().count;
  document.getElementById('count').textContent = formatNumberIndian(latest);

  // Define start times for growth periods
  const now = new Date();
  const istNow = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Kolkata' }));
  const y = istNow.getFullYear(), m = istNow.getMonth(), d = istNow.getDate();
  const startDay = istMidnightMs(y,m,d);
  const startMonth = istMidnightMs(y,m,1);
  const startYear = istMidnightMs(y,0,1); // Jan 1st of current year
  const dayOfWeek = istNow.getDay();
  const daysToMonday = (dayOfWeek === 0) ? 6 : (dayOfWeek - 1);
  const startWeek = startDay - daysToMonday * DAY_MS;

  // Interpolate values at these start times from our generated logs
  const valDay = countAtTime(startDay) || latest - GROWTH_TODAY;
  const valWeek = countAtTime(startWeek) || latest - GROWTH_WEEK;
  const valMonth = countAtTime(startMonth) || latest - GROWTH_MONTH;
  const valYear = countAtTime(startYear); // Will be correctly interpolated now

  if (valYear === null) {
      console.warn("Could not interpolate start-of-year value");
  }

  // Update growth card numbers
  document.getElementById('dailyGrowth').textContent = formatGrowth(latest - valDay);
  document.getElementById('dailyPrev').textContent = `from ${toISTDate(startDay)}`;
  document.getElementById('weeklyGrowth').textContent = formatGrowth(latest - valWeek);
  document.getElementById('weeklyPrev').textContent = `from ${toISTDate(startWeek)}`;
  document.getElementById('monthlyGrowth').textContent = formatGrowth(latest - valMonth);
  document.getElementById('monthlyPrev').textContent = `from ${toISTDate(startMonth)}`;
  document.getElementById('yearlyGrowth').textContent = formatGrowth(latest - valYear);
  document.getElementById('yearlyPrev').textContent = `from ${toISTDate(startYear)}`;
  document.getElementById('lastUpdated').textContent = `Last updated: ${new Date().toLocaleString('en-IN', { timeZone:'Asia/Kolkata', dateStyle:'medium', timeStyle:'short' })}`;

  renderChart();
}

// Chart rendering function
function renderChart(){
  const ctx = document.getElementById('growthChart').getContext('2d');
  if(!logs.length) return;

  const now = Date.now();
  const rangeMsMap = { '24h': DAY_MS, '7d': 7*DAY_MS, '30d': 30*DAY_MS, '12m': 365*DAY_MS };
  const rangeMs = rangeMsMap[currentRange] || rangeMsMap['12m'];
  const rangeStart = now - rangeMs;

  // Filter logs for the selected time range
  const pts = logs.filter(l => l.time >= rangeStart && l.time <= now)
                  .map(p => ({ x: p.time, y: p.count }));

  // Ensure there's a point at the beginning of the range for a full graph
  if (!pts.length || pts[0].x > rangeStart) {
      const startVal = countAtTime(rangeStart);
      if (startVal !== null) {
          pts.unshift({ x: rangeStart, y: startVal });
      }
  }

  if (pts.length < 2) return; // Not enough data to draw

  // Y-axis scaling
  const yVals = pts.map(p => p.y);
  let yMin = Math.min(...yVals);
  let yMax = Math.max(...yVals);
  const padding = (yMax - yMin) * 0.1 || 1;
  yMin = Math.floor(yMin - padding);
  yMax = Math.ceil(yMax + padding);

  if(chart){ chart.destroy(); }
  const unit = currentRange === '24h' ? 'hour' : 'day';

  chart = new Chart(ctx, {
    type: 'line',
    data: {
      datasets: [{
        label: 'Subscribers',
        data: pts,
        borderColor: '#4CAF50',
        borderWidth: 2,
        pointRadius: 0,
        tension: 0.1,
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      scales: {
        x: {
          type: 'time',
          time: { unit: (currentRange === '12m' ? 'month' : unit) },
          ticks: { color: 'rgba(255,255,255,0.75)' },
          grid: { color: 'rgba(255,255,255,0.06)' }
        },
        y: {
          min: yMin,
          max: yMax,
          ticks: { color: 'rgba(255,255,255,0.75)', callback: v => formatNumberIndian(v) },
          grid: { color: 'rgba(255,255,255,0.06)' }
        }
      },
      plugins: {
        legend: { display: false },
        tooltip: { callbacks: { label: ctx => `Subscribers: ${formatNumberIndian(ctx.parsed.y)}` } }
      }
    }
  });
}

// Tab button event listeners
document.querySelectorAll('.tab-btn').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelector('.tab-btn.active').classList.remove('active');
    btn.classList.add('active');
    currentRange = btn.dataset.range;
    renderChart();
  });
});

// Initial load and auto-update
updateSubs();
setInterval(updateSubs, 60 * 60 * 1000);
</script>
</body>
</html>
